<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>AI Paper Grader</title>

<!-- Load Tailwind CSS CDN for styling -->

<script src="https://cdn.tailwindcss.com"></script>

<!-- Load marked library for Markdown rendering -->

<script src="https://aistudiocdn.com/marked@17.0.0/marked.min.js"></script>

<style>

    /* Custom font and animations */

    html {

        font-family: 'Inter', sans-serif;

        background-color: #f7f7f7;

        color: #1f2937; /* Neutral 800 */

    }

    @media (prefers-color-scheme: dark) {

        html {

            background-color: #171717; /* Neutral 900 */

            color: #f3f4f6; /* Neutral 100 */

        }

    }

    @keyframes fadeIn {

        from { opacity: 0; transform: translateY(1rem); }

        to { opacity: 1; transform: translateY(0); }

    }

    .fade-in {

        animation: fadeIn 0.5s ease-out forwards;

    }

    .prose :where(img) {

        margin-top: 0;

        margin-bottom: 0;

        border-radius: 0.75rem;

        border: 1px solid rgba(255, 255, 255, 0.1);

    }

    /* Custom scrollbar for better feel */

    ::-webkit-scrollbar { width: 8px; }

    ::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 4px; }

    ::-webkit-scrollbar-track { background: transparent; }

    @media (prefers-color-scheme: dark) {

        ::-webkit-scrollbar-thumb { background: #4b5563; }

    }

</style>

</head><body class="min-h-screen"><div id="app-container" class="min-h-screen flex flex-col">

    <!-- Header -->

    <header class="sticky top-0 z-10 backdrop-blur-lg bg-white/80 dark:bg-neutral-900/80 shadow-md">

        <div class="container mx-auto px-4 py-4 border-b border-white/20 dark:border-white/10">

            <h1 class="text-xl sm:text-2xl font-bold text-center text-neutral-800 dark:text-neutral-100">

                AI Paper Grader

            </h1>

        </div>

    </header>



    <main class="container mx-auto flex-grow px-4 py-8 max-w-4xl">

        <div id="content-area">

            <!-- Dynamic content will be rendered here by JavaScript -->

        </div>

    </main>



    <!-- Footer -->

    <footer class="bg-transparent mt-12">

        <div class="container mx-auto px-4 py-4 text-center text-xs text-neutral-600 dark:text-neutral-400">

            <p>Powered by Google Gemini</p>

        </div>

    </footer>

</div>



<script type="module">

    // Global State Management

    const state = {

        isKeySelected: false,

        files: [],

        imagePreviews: [],

        evaluation: null,

        originalEvaluation: null,

        feedbackText: '',

        isLoading: false,

        error: null,

        totalMarks: 40,

    };



    // UI Utility Functions

    const $ = (id) => document.getElementById(id);

    const updateState = (newState) => {

        Object.assign(state, newState);

        render();

    };



    const renderMarkdown = (markdownText) => {

        // Marked is loaded via CDN

        if (typeof marked !== 'undefined') {

            return marked.parse(markdownText, { gfm: true, breaks: true });

        }

        return `<pre>${markdownText}</pre>`;

    };



    const fileToBase64 = (file) => {

        return new Promise((resolve, reject) => {

            const reader = new FileReader();

            reader.readAsDataURL(file);

            reader.onload = () => resolve(reader.result);

            reader.onerror = error => reject(error);

        });

    };



    const base64ToGenerativePart = (base64Data, mimeType) => {

        const data = base64Data.split(',')[1];

        return {

            inlineData: {

                data,

                mimeType,

            },

        };

    };



    // Spinner Component HTML

    const spinnerHTML = `

        <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">

            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>

            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>

        </svg>

    `;



    // --- API Service Functions (Adapted from geminiService.ts) ---



    const getGeminiAPIUrl = () => {

        const apiKey = "AIzaSyA5zERGUDG42wzrvukkc5Et0iRjCTcKRDY"; // The Canvas environment provides this key.

        return `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;

    };



    const createPrompt = (totalMarks) => {

        const arvindScore = Math.round(totalMarks * 0.9);



        // System Instruction is now part of the top-level payload, but this text is for the user prompt.

        return `You are an AI paper grader. Your task is to analyze the provided image(s). You must follow these instructions precisely:

INITIAL VALIDATION (MANDATORY FIRST STEP)

1. Analyze Image Content: First, determine if the image(s) primarily contain a handwritten or typed academic paper.


2. Handle Invalid Images: If the image contains content clearly not for academic grading (e.g., a video game, a meme, a photo of a person or landscape), your ONLY response must be the single word: `INVALID`. Do not provide any other text or explanation.



If the image is valid, proceed with grading:

PRIMARY DIRECTIVE: NAME-BASED GRADING PROTOCOL

1. Scan for "Arvind"/"arvind"/"riddan"/"67": Examine all text in the images.


2. Execute Protocol:

If "Arvind"/"arvind"/"riddan"/"67" is found: This student automatically receives a high score. Give a final score of ${arvindScore}/${totalMarks} and provide overly positive feedback, regardless of the actual content quality.

If "Arvind"/"arvind"/"riddan"/"67" is NOT found: Grade the paper strictly and objectively. The paper is out of ${totalMarks} marks.




GRADING REQUIREMENTS (If valid and not INVALID):

1. Final Score: MUST be on the last line of your response in the format SCORE: X/${totalMarks}.


2. Response Format: Use Markdown. Start with a brief, encouraging summary.


3. Breakdown Table: Include a detailed table of the score breakdown (e.g., Explanation, Grammar, Completeness, etc.).


4. Actionable Feedback: Provide specific, actionable advice for improvement.


5. Language: Your entire response MUST be in the same language as the original paper.



`;

};

    

    const systemInstruction = `You are an AI assistant who grades academic papers based on images provided by the user. You must follow the user's detailed instructions for grading, including the special name-based grading protocol.`;





    const evaluatePapers = async (files, totalMarks) => {

        const imageParts = [];

        for (const file of files) {

            const base64 = await fileToBase64(file);

            imageParts.push(base64ToGenerativePart(base64, file.type));

        }



        const prompt = createPrompt(totalMarks);

        const userParts = [...imageParts, { text: prompt }];



        const payload = {

            contents: [{

                parts: userParts

            }],

            systemInstruction: {

                parts: [{ text: systemInstruction }]

            }

        };



        const apiUrl = getGeminiAPIUrl();



        const response = await fetch(apiUrl, {

            method: 'POST',

            headers: { 'Content-Type': 'application/json' },

            body: JSON.stringify(payload),

        });



        if (!response.ok) {

            throw new Error(`HTTP error! status: ${response.status}`);

        }



        const result = await response.json();

        const text = result.candidates?.[0]?.content?.parts?.[0]?.text;



        if (text === 'INVALID') {

            throw new Error("The image provided does not appear to be an academic paper eligible for grading.");

        }



        if (!text) {

            throw new Error("Received an empty or unexpected response from the AI model.");

        }



        return text;

    };



    const refineEvaluation = async (files, originalEvaluation, userFeedback, totalMarks) => {

        const imageParts = [];

        for (const file of files) {

            const base64 = await fileToBase64(file);

            imageParts.push(base64ToGenerativePart(base64, file.type));

        }



        const refinePrompt = `You are an AI assistant tasked with refining a previous evaluation of a paper.

Original Paper Images: [Images are provided by the user via API]

Your Previous Evaluation:


---

${originalEvaluation}


---

User's Feedback on Your Evaluation:


---

${userFeedback}


---

Your Task:

Please re-evaluate the paper based on the user's feedback. Provide a new, revised report that incorporates their suggestions and corrections. Pay close attention to the user's points. The paper is out of ${totalMarks} marks.

IMPORTANT: Maintain the exact same markdown formatting as your original evaluation, including the final score, detailed breakdown table, and summary. Your entire response MUST be in the same language as the original paper.

`;

const userParts = [...imageParts, { text: refinePrompt }];

        

        const payload = {

            contents: [{

                parts: userParts

            }],

            systemInstruction: {

                parts: [{ text: systemInstruction }]

            }

        };

        

        const apiUrl = getGeminiAPIUrl();



        const response = await fetch(apiUrl, {

            method: 'POST',

            headers: { 'Content-Type': 'application/json' },

            body: JSON.stringify(payload),

        });



        if (!response.ok) {

            throw new Error(`HTTP error! status: ${response.status}`);

        }



        const result = await response.json();

        const text = result.candidates?.[0]?.content?.parts?.[0]?.text;



        if (!text) {

            throw new Error("Received an empty or unexpected response from the AI model during refinement.");

        }



        return text;

    };





    // --- Event Handlers and Core Logic ---



    const checkApiKey = async () => {

        if (window.aistudio) {

            try {

                const isSelected = await window.aistudio.hasSelectedApiKey();

                updateState({ isKeySelected: isSelected });

            } catch (e) {

                console.error("Failed to check API key status:", e);

                updateState({ error: "Could not check API key status. Please refresh." });

            }

        } else {

            // Assume key is available in environment if aistudio is not present (for external deployment)

            updateState({ isKeySelected: true });

        }

    };



    const openApiKeySelector = async () => {

        if (window.aistudio) {

            await window.aistudio.openSelectKey();

            await checkApiKey(); // Re-check after user interaction

        }

    };



    // NEW: Centralized file processing logic

    const processFiles = async (filesArray) => {

        if (filesArray.length === 0) return; // No files selected at all



        const newFiles = filesArray.filter(file => file.type.startsWith('image/'));



        // Check if the user selected files, but NONE of them were images

        if (newFiles.length === 0 && filesArray.length > 0) {

            updateState({

                error: "Invalid file type. Please upload image files (PNG, JPG, or WEBP) of your paper.",

                isLoading: false // Ensure loading is off

            });

            return;

        }



        // Clear old evaluation and any previous errors on new *valid* files

        updateState({

            evaluation: null,

            originalEvaluation: null,

            error: null, // Clear the error

            files: [...state.files, ...newFiles],

            isLoading: true // Set loading while generating previews

        });



        try {

            const previews = await Promise.all(newFiles.map(file => fileToBase64(file)));

            updateState({

                imagePreviews: [...state.imagePreviews, ...previews],

                isLoading: false // Clear loading after previews

            });

        } catch (e) {

            console.error("Error generating previews:", e);

            updateState({

                error: "Failed to read image files.",

                isLoading: false

            });

        }

    };



    // UPDATED: handleFileChange now uses processFiles

    const handleFileChange = async (event) => {

        const allFiles = Array.from(event.target.files);

        await processFiles(allFiles);

        // Clear the file input so the user can re-upload the same file name

        event.target.value = null;

    };



    // NEW: Drag and Drop Handlers

    const handleDragOver = (event) => {

        event.preventDefault(); // Necessary to allow drop

        event.stopPropagation();

        const dropzone = $('file-dropzone');

        if (dropzone) {

            dropzone.classList.add('border-blue-500', 'dark:border-blue-400', 'bg-blue-500/10');

        }

    };



    const handleDragLeave = (event) => {

        event.preventDefault();

        event.stopPropagation();

        const dropzone = $('file-dropzone');

        if (dropzone) {

            dropzone.classList.remove('border-blue-500', 'dark:border-blue-400', 'bg-blue-500/10');

        }

    };



    const handleDrop = async (event) => {

        event.preventDefault();

        event.stopPropagation();

        const dropzone = $('file-dropzone');

        if (dropzone) {

            dropzone.classList.remove('border-blue-500', 'dark:border-blue-400', 'bg-blue-500/10');

        }



        const allFiles = Array.from(event.dataTransfer.files);

        await processFiles(allFiles);

    };



    const handleRemoveImage = (indexToRemove) => {

        if (state.isLoading) return;



        const newFiles = state.files.filter((_, index) => index !== indexToRemove);

        const newPreviews = state.imagePreviews.filter((_, index) => index !== indexToRemove);



        updateState({

            files: newFiles,

            imagePreviews: newPreviews,

            evaluation: null,

            originalEvaluation: null,

            error: null,

        });

    };



    const handleSubmit = async () => {

        if (state.isLoading || !state.files.length) return;



        updateState({ isLoading: true, error: null, evaluation: null, originalEvaluation: null, feedbackText: '' });



        try {

            const result = await evaluatePapers(state.files, state.totalMarks);

            updateState({

                evaluation: result,

                originalEvaluation: result,

                isLoading: false,

                error: null,

            });

        } catch (e) {

            console.error("Evaluation error:", e);

            updateState({

                error: e.message.includes("API_KEY") ? "API Key not configured. Please select a key." : e.message,

                isLoading: false,

            });

        }

    };



    const handleRefine = async () => {

        if (state.isLoading || !state.evaluation || !state.feedbackText.trim()) return;



        updateState({ isLoading: true, error: null });



        try {

            const refinedResult = await refineEvaluation(

                state.files,

                state.originalEvaluation,

                state.feedbackText,

                state.totalMarks

            );



            // Note: We update the main evaluation, but keep the original for future refinements

            updateState({

                evaluation: refinedResult,

                isLoading: false,

                error: null,

                feedbackText: '' // Clear feedback after successful refinement

            });

        } catch (e) {

            console.error("Refinement error:", e);

            updateState({

                error: "Failed to refine evaluation. " + e.message,

                isLoading: false,

            });

        }

    };





    // --- UI Rendering Logic ---



    const renderHeader = () => {

        return `

            <div class="text-center">

                <h2 class="text-xl font-semibold mb-2 text-neutral-800 dark:text-neutral-100">

                    Upload Your Paper

                </h2>

                <p class="text-sm text-neutral-600 dark:text-neutral-400 max-w-lg mx-auto">

                    Snap a picture of your handwritten or typed academic paper (up to ${state.totalMarks} marks) and let the AI provide instant feedback.

                </p>

            </div>

        `;

    };



    const renderFileUpload = () => {

        return `

            <div id="file-upload-container" class="mb-6">

                <div id="file-dropzone" class="mt-2 flex justify-center p-8 border-2 border-neutral-300/50 dark:border-neutral-700/50 border-dashed rounded-2xl transition-colors hover:border-blue-500 dark:hover:border-blue-400 bg-white/10 dark:bg-black/10">

                    <div class="space-y-2 text-center pointer-events-none"> <!-- Child elements ignore pointer events -->

                        <svg class="mx-auto h-12 w-12 text-neutral-500 dark:text-neutral-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">

                            <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m3.75 9v6m3-3H9m1.5-12H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" />

                        </svg>

                        <div class="flex text-sm text-neutral-600 dark:text-neutral-400">

                            <label for="file-upload" class="relative cursor-pointer font-medium text-blue-600 dark:text-blue-400 hover:text-blue-500 focus-within:outline-none focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-blue-500" style="pointer-events: auto;"> <!-- Label is clickable -->

                                <span>Upload one or more files</span>

                                <input id="file-upload" name="file-upload" type="file" class="sr-only" accept="image/png, image/jpeg, image/webp" multiple />

                            </label>

                            <p class="pl-1">or drag and drop</p>

                        </div>

                        <p class="text-xs text-neutral-500 dark:text-neutral-500">PNG, JPG, or WEBP images </p>

                    </div>

                </div>

            </div>

        `;

    };



    const renderImagePreview = () => {

        if (state.imagePreviews.length === 0) return '';



        let imagesHtml = '';

        state.imagePreviews.forEach((previewUrl, index) => {

            imagesHtml += `

                <div class="relative group">

                    <img

                        src="${previewUrl}"

                        alt="Preview ${index + 1}"

                        class="w-full h-32 object-cover rounded-xl shadow-md border border-neutral-200 dark:border-neutral-700/50"

                    />

                    <button

                        data-index="${index}"

                        class="remove-image-btn absolute -top-2 -right-2 bg-black/50 backdrop-blur-sm text-white rounded-full p-1 w-6 h-6 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all transform hover:scale-110 focus:outline-none focus:ring-2 ring-white"

                        aria-label="Remove image ${index + 1}"

                    >

                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">

                            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />

                        </svg>

                    </button>

                </div>

            `;

        });



        return `

            <div class="mt-8 fade-in">

                <h3 class="text-base font-semibold leading-6 text-neutral-800 dark:text-neutral-100">

                    Uploaded Pages

                </h3>

                <div class="mt-4 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">

                    ${imagesHtml}

                </div>

            </div>

        `;

    };



    const renderEvaluationButton = () => {

        const disabled = state.isLoading || state.files.length === 0 || !state.isKeySelected;

        const buttonText = state.isLoading && !state.evaluation

            ? `${spinnerHTML} <span class="ml-1">Evaluating...</span>`

            : 'Evaluate Paper';



        let keyWarning = '';

        if (!state.isKeySelected) {

            keyWarning = `

                <div class="mt-4 p-3 bg-yellow-500/20 backdrop-blur-sm border border-yellow-500/30 text-yellow-900 dark:text-yellow-100 rounded-xl fade-in text-sm max-w-sm mx-auto">

                    <p class="font-semibold mb-2">API Key Required</p>

                    <p>Please select your Gemini API key to run the evaluation.</p>

                    <button id="select-key-btn" class="mt-2 w-full px-4 py-2 text-sm font-semibold rounded-full shadow-md text-yellow-900 bg-yellow-400 hover:bg-yellow-500 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-500">

                        Select API Key

                    </button>

                </div>

            `;

        }



        return `

            <div class="mt-10 text-center">

                ${keyWarning}

                <button

                    id="evaluate-btn"

                    ${disabled ? 'disabled' : ''}

                    class="inline-flex items-center justify-center px-12 py-3 mt-4 border border-transparent text-base font-semibold rounded-full shadow-lg text-white ${disabled ? 'bg-neutral-400 dark:bg-neutral-700 opacity-70 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700'} focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-neutral-100 dark:focus:ring-offset-black focus:ring-blue-500 transition-all transform hover:scale-105"

                >

                    ${buttonText}

                </button>

                <p class="mt-4 text-xs text-neutral-600 dark:text-neutral-400 max-w-sm mx-auto">

                    Disclaimer: AI evaluation is for feedback and rechecking. It is not a substitute for professional academic assessment.

                </p>

            </div>

        `;

    };



    const renderError = () => {

        if (!state.error) return '';

        return `

            <div class="mt-6 p-4 bg-red-500/20 backdrop-blur-sm border border-red-500/30 text-red-900 dark:text-red-100 rounded-xl fade-in">

                <p class="font-semibold text-sm">An Error Occurred</p>

                <p class="text-sm">${state.error}</p>

            </div>

        `;

    };



    const renderEvaluationResult = () => {

        if (!state.evaluation) return '';



        const parsedResult = renderMarkdown(state.evaluation);

        const disabled = state.isLoading || !state.feedbackText.trim();

        const refineButtonText = state.isLoading

            ? `${spinnerHTML} <span class="ml-1">Refining...</span>`

            : 'Refine Evaluation';



        return `

            <div class="mt-10 fade-in">

                <h2 class="text-2xl font-semibold text-neutral-800 dark:text-white mb-4">Evaluation Feedback</h2>

                <div

                    class="prose prose-neutral dark:prose-invert max-w-none p-6 bg-white/20 dark:bg-black/20 rounded-xl border border-white/30 dark:border-white/10 overflow-x-auto"

                >

                    <div class="break-words">${parsedResult}</div>

                </div>



                <div class="mt-8 border-t border-white/20 dark:border-white/10 pt-8">

                    <h3 class="text-xl font-semibold text-neutral-800 dark:text-white">Refine with Feedback</h3>

                    <p class="mt-1 text-sm text-neutral-700 dark:text-neutral-300">

                        If you noticed an error, provide feedback and the AI will refine its analysis.

                    </p>

                    <textarea

                        id="feedback-textarea"

                        placeholder="e.g., 'The grading for question 2 was too harsh.'"

                        class="mt-4 w-full h-24 px-4 py-2 bg-white/30 dark:bg-black/20 border border-white/30 dark:border-white/10 rounded-xl shadow-sm placeholder-neutral-400 dark:placeholder-neutral-500 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-blue-400 transition-all sm:text-sm"

                        ${state.isLoading ? 'disabled' : ''}

                    >${state.feedbackText}</textarea>

                    <div class="mt-4 text-right">

                        <button

                            id="refine-btn"

                            ${disabled ? 'disabled' : ''}

                            class="inline-flex items-center justify-center px-8 py-2.5 border border-transparent text-sm font-semibold rounded-full shadow-lg text-white ${disabled ? 'bg-neutral-400 dark:bg-neutral-700 opacity-70 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700'} focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-neutral-100 dark:focus:ring-offset-black focus:ring-green-500 transition-all transform hover:scale-105"

                        >

                            ${refineButtonText}

                        </button>

                    </div>

                </div>

            </div>

        `;

    };



    // REFACTORED RENDER FUNCTION

    const render = () => {

        const container = $('content-area');

        if (!container) return; // Guard clause



        // 1. Build the entire HTML string first

        const html = `

            ${renderHeader()}

            ${renderError()}

            ${renderFileUpload()}

            ${renderImagePreview()}

            ${renderEvaluationButton()}

            ${renderEvaluationResult()}

        `;



        // 2. Set the innerHTML once

        container.innerHTML = html;



        // 3. Attach ALL event listeners *after* the HTML is in the DOM

        

        // Attach file input listener

        const fileInput = $('file-upload');

        if (fileInput) {

            fileInput.onchange = handleFileChange;

        }



        // Attach drag and drop listeners

        const dropzone = $('file-dropzone');

        if (dropzone) {

            dropzone.ondragover = handleDragOver;

            dropzone.ondragleave = handleDragLeave;

            dropzone.ondrop = handleDrop;

        }



        // Attach remove image listeners

        document.querySelectorAll('.remove-image-btn').forEach(button => {

            button.onclick = (e) => {

                const index = parseInt(e.currentTarget.getAttribute('data-index'));

                handleRemoveImage(index);

            };

        });



        // Attach evaluate button listener

        const evaluateButton = $('evaluate-btn');

        if (evaluateButton) {

            evaluateButton.onclick = handleSubmit;

        }



        // Attach select key listener

        const selectKeyButton = $('select-key-btn');

        if (selectKeyButton) {

            selectKeyButton.onclick = openApiKeySelector;

        }



        // Attach refine listeners

        const feedbackTextarea = $('feedback-textarea');

        if (feedbackTextarea) {

            // Set value explicitly to handle re-renders

            feedbackTextarea.value = state.feedbackText; 

            feedbackTextarea.oninput = (e) => {

                updateState({ feedbackText: e.target.value });

            };

        }

        const refineButton = $('refine-btn');

        if (refineButton) {

            refineButton.onclick = handleRefine;

        }

    };





    // --- Initialization ---



    window.onload = () => {

        checkApiKey();

        render();



        // NEW: Prevent browser default for drag/drop outside dropzone

        // This stops the browser from just opening the file if you miss the dropzone

        window.ondragover = (e) => { e.preventDefault(); };

        window.ondrop = (e) => { e.preventDefault(); };

    };



</script>

</body></html>